import type { ComputedPlayerData, ComputedKPI, Fix, Win, TimelineMarker } from '../types'
import type { RuleCategory } from '../../constants/ruleCategories'

export interface V3Rule {
    id: string
    roles: string[]
    atMin?: number
    endOfGame?: boolean
    when: {
        operator: 'delta_less_than' | 'delta_greater_than'
        kpi: string
        value: number
    }
    severity: number
    type: 'fix' | 'win'
    category: RuleCategory
    header: string
    description: string
}

export interface V3Ruleset {
    rulesVersion: string
    rules: V3Rule[]
}

export class StratzRuleEngine {
    private static ruleset: V3Ruleset | null = null

    static async loadRuleset(): Promise<V3Ruleset> {
        if (!this.ruleset) {
            try {
                const response = await fetch('/ruleset.v3.jsonc')
                const text = await response.text()

                // Parse JSONC (remove comments)
                let jsonText = text
                    .replace(/\/\/.*$/gm, '') // Remove single-line comments
                    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove multi-line comments
                    .replace(/,\s*}/g, '}') // Remove trailing commas
                    .replace(/,\s*]/g, ']') // Remove trailing commas in arrays

                this.ruleset = JSON.parse(jsonText)
                console.log('Loaded v3 ruleset:', this.ruleset)
            } catch (error) {
                console.error('Failed to load v3 ruleset:', error)
                throw new Error('Failed to load analysis ruleset')
            }
        }
        return this.ruleset!
    }

    static async analyzePlayer(
        playerData: ComputedPlayerData,
        kpis: ComputedKPI[]
    ): Promise<{
        fixes: Fix[]
        wins: Win[]
        timeline: TimelineMarker[]
        summary: string
    }> {
        const startTime = Date.now()
        const ruleset = await this.loadRuleset()

        // Get player's actual role from the data
        const playerRole = this.getPlayerRole(playerData)

        // Evaluate all rules that apply to this player
        const applicableRules = ruleset.rules.filter(rule =>
            rule.roles.includes('ALL') || rule.roles.includes(playerRole)
        )

        // Evaluate each rule
        const evaluatedRules = applicableRules
            .map(rule => {
                const matches = this.evaluateRule(rule, playerData, kpis)
                return {
                    ...rule,
                    matches
                }
            })
            .filter(rule => rule.matches)
            .sort((a, b) => b.severity - a.severity)

        // Separate fixes and wins
        let fixes = evaluatedRules
            .filter(rule => rule.type === 'fix')
            .slice(0, 3) // Ensure exactly 3 fixes

        let wins = evaluatedRules
            .filter(rule => rule.type === 'win')
            .slice(0, 2) // Ensure exactly 2 wins

        // If no rules matched, provide default feedback
        if (fixes.length === 0 && wins.length === 0) {
            fixes = [
                {
                    id: 'default_fix_1',
                    roles: ['ALL'],
                    atMin: 20,
                    when: { operator: 'delta_less_than', kpi: 'cs@10', value: -0.25 },
                    severity: 0.5,
                    type: 'fix',
                    category: 'General',
                    header: 'Focus on improving your overall game performance',
                    description: 'Focus on improving your overall game performance',
                    matches: true
                },
                {
                    id: 'default_fix_2',
                    roles: ['ALL'],
                    atMin: 20,
                    when: { operator: 'delta_less_than', kpi: 'kDA@20', value: -0.25 },
                    severity: 0.4,
                    type: 'fix',
                    category: 'General',
                    header: 'Work on your positioning and decision making',
                    description: 'Work on your positioning and decision making',
                    matches: true
                },
                {
                    id: 'default_fix_3',
                    roles: ['ALL'],
                    atMin: 20,
                    when: { operator: 'delta_less_than', kpi: 'networth@20', value: -0.25 },
                    severity: 0.3,
                    type: 'fix',
                    category: 'General',
                    header: 'Improve your farming efficiency and resource management',
                    description: 'Improve your farming efficiency and resource management',
                    matches: true
                }
            ]
            wins = [
                {
                    id: 'default_win_1',
                    roles: ['ALL'],
                    atMin: 20,
                    when: { operator: 'delta_greater_than', kpi: 'kDA@20', value: 0.25 },
                    severity: 0.4,
                    type: 'win',
                    category: 'General',
                    header: 'Good overall game awareness and decision making',
                    description: 'Good overall game awareness and decision making',
                    matches: true
                },
                {
                    id: 'default_win_2',
                    roles: ['ALL'],
                    atMin: 20,
                    when: { operator: 'delta_greater_than', kpi: 'cs@10', value: 0.25 },
                    severity: 0.3,
                    type: 'win',
                    category: 'General',
                    header: 'Solid mechanical skills and execution',
                    description: 'Solid mechanical skills and execution',
                    matches: true
                }
            ]
        }

        // Convert to Fix/Win format
        const formattedFixes: Fix[] = fixes.map(rule => ({
            title: rule.header,
            description: rule.description,
            dataComparison: this.generateDataComparison(rule, playerData),
            priority: Math.round((1 - rule.severity) * 3) + 1, // Convert severity to priority (1-3)
            category: rule.category,
            confidence: Math.round(rule.severity * 3) // Convert severity to confidence (1-3)
        }))

        const formattedWins: Win[] = wins.map(rule => ({
            title: rule.header,
            description: rule.description,
            dataComparison: this.generateDataComparison(rule, playerData),
            kpi: rule.when.kpi,
            confidence: Math.round(rule.severity * 3) // Convert severity to confidence (1-3)
        }))

        // Generate timeline (simplified for now)
        const timeline: TimelineMarker[] = this.generateTimeline(playerData)

        // Generate summary
        const summary = this.generateSummary(formattedFixes, formattedWins, playerData)

        const endTime = Date.now()
        console.log(`Rule engine analysis completed in ${endTime - startTime}ms`)

        const result = {
            fixes: formattedFixes,
            wins: formattedWins,
            timeline,
            summary
        }

        return result
    }

    private static getPlayerRole(playerData: ComputedPlayerData): string {
        // Map the role from playerData to the format expected by rules
        const roleMap: Record<string, string> = {
            'pos1': 'POSITION_1',
            'pos2': 'POSITION_2',
            'pos3': 'POSITION_3',
            'pos4': 'POSITION_4',
            'pos5': 'POSITION_5'
        }

        return roleMap[playerData.role] || 'POSITION_1'
    }

    private static evaluateRule(rule: V3Rule, playerData: ComputedPlayerData, kpis: ComputedKPI[]): boolean {
        // Handle end-of-game rules differently
        if (rule.endOfGame) {
            return this.evaluateEndOfGameRule(rule, playerData, kpis)
        }

        const { operator, kpi, value } = rule.when

        // Parse the KPI to get the metric name and time
        const [metricName, timeStr] = kpi.split('@')
        const targetTime = parseInt(timeStr || '0')

        if (!metricName) {
            console.warn(`Invalid KPI format: ${kpi}`)
            return false
        }

        // Get the player's value for this metric at the specified time
        const playerValue = this.getPlayerValueAtSpecificTime(metricName, targetTime, playerData, kpis)

        // Get the hero average value for this metric at the specified time
        const heroAverageValue = this.getHeroAverageValueAtTime(metricName, targetTime, playerData)

        if (heroAverageValue === null) {
            console.log(`No hero average data for ${metricName} at ${targetTime} minutes`)
            return false
        }

        // Calculate delta (percentage difference from average)
        const delta = (playerValue - heroAverageValue) / heroAverageValue

        // Apply the operator
        switch (operator) {
            case 'delta_less_than':
                return delta < value
            case 'delta_greater_than':
                return delta > value
            default:
                return false
        }
    }

    private static evaluateEndOfGameRule(rule: V3Rule, playerData: ComputedPlayerData, kpis: ComputedKPI[]): boolean {
        const { operator, kpi, value } = rule.when

        // For end-of-game rules, the KPI doesn't have a time component
        const metricName = kpi

        // Get end-of-game values (final values from the match)
        const playerValue = this.getEndOfGamePlayerValue(metricName, playerData)
        const heroAverageValue = this.getEndOfGameHeroAverageValue(metricName, playerData)

        if (heroAverageValue === null) {
            console.log(`No end-of-game hero average data for ${metricName}`)
            return false
        }

        // Calculate delta (percentage difference from average)
        const delta = (playerValue - heroAverageValue) / heroAverageValue

        // Apply the operator
        switch (operator) {
            case 'delta_less_than':
                return delta < value
            case 'delta_greater_than':
                return delta > value
            default:
                return false
        }
    }

    private static getPlayerValueAtSpecificTime(metricName: string, time: number, playerData: ComputedPlayerData, kpis: ComputedKPI[]): number {
        // Get minute-by-minute player data from stats
        const playerStats = playerData.stratzData?.playerStats

        if (!playerStats) {
            return this.getPlayerValueAtTimeFallback(metricName, time, playerData, kpis)
        }

        // Find the data up to the specific time (inclusive)
        const timeIndex = Math.floor(time)

        // Check if the stats arrays exist and have the required length
        if (!playerStats.impPerMinute || timeIndex >= playerStats.impPerMinute.length) {
            return this.getPlayerValueAtTimeFallback(metricName, time, playerData, kpis)
        }

        switch (metricName) {
            case 'kDA':
                // Calculate KDA from cumulative data - we don't have minute-by-minute kills/deaths
                // Use fallback for now
                return this.getPlayerValueAtTimeFallback(metricName, time, playerData, kpis)
            case 'deaths':
                // We don't have minute-by-minute deaths, use fallback
                return this.getPlayerValueAtTimeFallback(metricName, time, playerData, kpis)
            case 'heroDamage':
                // We don't have minute-by-minute hero damage, use fallback
                return this.getPlayerValueAtTimeFallback(metricName, time, playerData, kpis)
            case 'cs':
                // Use lastHitsPerMinute array - accumulate from index 0 to timeIndex
                return this.accumulateArrayValues(playerStats.lastHitsPerMinute, timeIndex)
            case 'xp':
                // Use experiencePerMinute array - accumulate from index 0 to timeIndex
                return this.accumulateArrayValues(playerStats.experiencePerMinute, timeIndex)
            case 'networth':
                return playerData.networth            case 'level':
                // level doesn't exist, estimate based on XP
                return Math.min(25, Math.floor((playerData.xpm * playerData.match_minutes / 60) / 1000) + 1)
            case 'killContribution':
                return playerData.kpct
            case 'towerDamage':
                // tower_damage doesn't exist, use tdpm scaled to match duration
                return playerData.tdpm * playerData.match_minutes / 60
            case 'campsStacked':
                return playerData.stacks
            case 'abilityCasts':
                // ability_casts doesn't exist, estimate based on match duration
                return Math.floor(2 * playerData.match_minutes) // Rough estimate
            case 'healingAllies':
                // healing doesn't exist, use a default
                return 0
            case 'supportGold':
                return playerData.gpm * playerData.match_minutes / 60 * 0.3 // Estimate support gold
            default:
                console.warn(`Unknown end-of-game metric: ${metricName}`)
                return 0
        }
    }

    private static getEndOfGameHeroAverageValue(metricName: string, playerData: ComputedPlayerData): number | null {
        if (!playerData.stratzData?.heroAverage) {
            console.log('No hero average data available')
            return null
        }

        // Get the last (final) hero average data entry
        const finalHeroAvg = playerData.stratzData.heroAverage
            .sort((a, b) => b.time - a.time)[0]

        if (!finalHeroAvg) {
            console.log('No final hero average data found')
            return null
        }

        console.log(`Using final hero average data at time ${finalHeroAvg.time} for metric ${metricName}`)

        switch (metricName) {
            case 'courierKills':
                return finalHeroAvg.courierKills || 0
            case 'kDA':
                return finalHeroAvg.kills / Math.max(finalHeroAvg.deaths, 1)
            case 'deaths':
                return finalHeroAvg.deaths || 0
            case 'heroDamage':
                return finalHeroAvg.damage || 0
            case 'cs':
                return finalHeroAvg.cs || 0
            case 'xp':
                return finalHeroAvg.xp || 0
            case 'networth':
                return playerData.networth